Imagine we set the concurrency to 4. We do not configure any handlers. As soon as we run `Start()`, the `default` case of the `for` loop in `Start()` will be able to pull four messages from Kafka and send them into the work channel (because there are 4 routines listening to that channel). Each of these routines will then figure out that there is no handler configured for the message's topic. They will all try to send an error into the critical error channel and then return.

However, there is only one routine listening to the critical errors channel (the loop that is running in `Start()`). That means that only one of the routines will be able to actually send an error. That error will trigger a call to `Stop()`. The call to stop closes the done channel and then waits for all the work to be completed. However, the remaining routines are blocked because they are trying to send an error onto the critical error channel. That channel is blocked, because it is waiting for the goroutines to finish their work, which they can't, because they cannot send their error, etc. etc. This means that the call to `Stop()` will never be able to complete.
